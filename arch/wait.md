# 同步异步

## 概要
* 同步异步的操作，接收方和处理接收方不一定在一个应用进程内，能支持分布式。
* 消息通过MQ完成通知，数据通过分布式存储完成传递。
* 实例：管理系统上点击终端截图，管理系统前端通知后端，后端通知终端截图，在后端发命令给终端后，后端开始等待，等待终端发回截图结果后，再继续操作，返回管理系统截图。这样管理系统上的截图可以同步显示出来。

| 角色 | 作用 | 实例 |
| :----: | ---- | ---- |
| 发起方 | 发起请求并等待 | 管理系统截图 |
| 接收方 | 发起请求并等待 | 后端(API)发起截图 |
| 处理方 | 处理 | 终端截图 |
| 处理接收方 | 收到请求，释放“发起方”的等待锁，不一定是接收方 | 后端(API)处理截图 |
| 同步服务调用库 | 服务于后端，调用同步服务 | 无 |
| 同步服务 | 独立服务，协调通讯和数据，通过API提供服务 | 无 |

# 流程
## 应用
### 初始化
* 需求发起
* 每个应用都长期订阅，而不是每次有需求时订阅
* 每个应用都是唯一的应用号

```
同步服务调用库.启用同步服务(应用实例号)
```

### 接收方
```
生成异步请求的GUID
发起异步请求(GUID)
lock = 同步服务调用库.申请锁(应用实例号, GUID)
lock.wait(5000) // 当前线程等待lock解锁，5秒自动释放
result = 同步服务调用库.获取结果(GUID)
return result
```

### 处理接收方
```
同步服务调用库.持久化结果(GUID) // 如存放到redis
同步服务调用库.服务完成(GUID)
```

## 同步服务调用库
### 启用同步服务(应用实例号)
```
同步服务.生成订阅队列(应用实例号)
应用.订阅该队列
```

### 申请锁(应用实例号, GUID)
```
lock = 生成锁(GUID) // 必须在同一个应用进程生成，否则无法解锁
map.add(GUID, {lock, 应用实例号})
return lock
```

### 服务完成(GUID)
```
同步服务.服务完成(GUID)

同步服务.服务完成(GUID) {
  应用实例号 = 获取应用实例号(GUID)
  获取订阅队列(应用实例号)
  队列.服务完成(GUID) // 会触发 同步服务调用库.服务完成的通知接收(GUID)
}
```

### 服务完成的通知接收(GUID)
```
lock = map.get(GUID);
lock.release() // 解锁
```

### 持久化结果(GUID, result)
```
redis.put(GUID, result);
```

### 获取结果(GUID)
```
return redis.get(GUID);
```
